<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>54の博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="不懂不会，撸码就完事了">
<meta property="og:type" content="website">
<meta property="og:title" content="54の博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="54の博客">
<meta property="og:description" content="不懂不会，撸码就完事了">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="54の博客">
<meta name="twitter:description" content="不懂不会，撸码就完事了">
  
    <link rel="alternate" href="/atom.xml" title="54の博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">54の博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术.问题.思考的记录</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/07/集合/" class="article-date">
  <time datetime="2018-05-07T14:59:35.000Z" itemprop="datePublished">2018-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/07/集合/">集合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java中的集合框架大类可分为Collection和Map；两者的区别：</p>
<ul>
<li>Collection是单列集合;Map是双列集合</li>
<li>Collection中只有Set系列要求元素唯一;Map中建需要唯一，值可以重复</li>
<li>Collection的数据结构是针对元素的;Map的数据结构是针对建的<h2 id="Collection体系："><a href="#Collection体系：" class="headerlink" title="Collection体系："></a>Collection体系：</h2> Collection包括两大体系，List和Set<h5 id="List的特点"><a href="#List的特点" class="headerlink" title="List的特点"></a>List的特点</h5> 存取有序，有索引，可以根据索引取值，元素可以重<h5 id="Set的特点"><a href="#Set的特点" class="headerlink" title="Set的特点"></a>Set的特点</h5>  存取无需，元素不可以重复<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3>  list包括Arraylist,LinkedList,Vector(已过时)<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList:"></a>ArrayList:</h5>  底层是数值结构，查询快，增删慢<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package 集合;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">public class Test &#123;</span><br><span class="line">使用ArrayList进行添加和遍历</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(&quot;接口1&quot;);</span><br><span class="line">        list.add(&quot;接口2&quot;);</span><br><span class="line">        list.add(&quot;接口3&quot;);</span><br><span class="line">        // 第一种遍历方式,使用迭代器</span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        while(it.hasNext())&#123;</span><br><span class="line">            String next = it.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;-------------------&quot;);</span><br><span class="line">        // 第二种遍历方式，使用foreach</span><br><span class="line">        for (String str : list)&#123;</span><br><span class="line">            System.err.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList:"></a>LinkedList:</h5><pre><code>是基于链表结构实现的，所以查询速度慢，增删速度快，提供了特殊的方法，对头尾的元素操作（进行增删查）

使用LinkedList来实现栈和队列；栈是先进后出，而队列是先进先出
</code></pre><h5 id="LinkedList栈的实现"><a href="#LinkedList栈的实现" class="headerlink" title="LinkedList栈的实现"></a>LinkedList栈的实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.sihai.classtest;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"> 利用LinkedList来模拟栈</span><br><span class="line"> 栈的特点：先进后出</span><br><span class="line"> @author sihai</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">public class MyStack &#123;</span><br><span class="line">    private LinkedList&lt;String&gt; linkList = new LinkedList&lt;String&gt;();</span><br><span class="line">     压栈</span><br><span class="line">    public void push(String str)&#123;</span><br><span class="line">        linkList.addFirst(str);</span><br><span class="line">    &#125;</span><br><span class="line">     出栈</span><br><span class="line">    public String pop()&#123;</span><br><span class="line">        return linkList.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    查看</span><br><span class="line">    public String peek()&#123;</span><br><span class="line">        return linkList.peek();</span><br><span class="line">    &#125;</span><br><span class="line">     判断是否为空</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return linkList.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package  集合;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         测试栈</span><br><span class="line">        StackTest stack = new StackTest();</span><br><span class="line">        stack.push(&quot;我是第1个进去的&quot;);</span><br><span class="line">        stack.push(&quot;我是第2个进去的&quot;);</span><br><span class="line">        stack.push(&quot;我是第3个进去的&quot;);</span><br><span class="line">        stack.push(&quot;我是第4个进去的&quot;);</span><br><span class="line">        stack.push(&quot;我是第5个进去的&quot;);</span><br><span class="line">         取出</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            String pop = stack.pop();</span><br><span class="line">            System.out.println(pop);</span><br><span class="line">        &#125;</span><br><span class="line">         打印结果</span><br><span class="line">        我是第5个进去的</span><br><span class="line">        我是第4个进去的</span><br><span class="line">        我是第3个进去的</span><br><span class="line">        我是第2个进去的</span><br><span class="line">        我是第1个进去的</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="LinkedList队列的实现"><a href="#LinkedList队列的实现" class="headerlink" title="LinkedList队列的实现:"></a>LinkedList队列的实现:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package 集合;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">  利用linkedList来实现队列</span><br><span class="line"> 队列: 先进先出</span><br><span class="line"> @author sihai</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">public class QueueTest &#123;</span><br><span class="line">    private LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;();</span><br><span class="line">     放入</span><br><span class="line">    public void put(String str)&#123;</span><br><span class="line">        link.addFirst(str);</span><br><span class="line">    &#125;</span><br><span class="line">     获取</span><br><span class="line">    public String get()&#123;</span><br><span class="line">        return link.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">     判断是否为空</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return link.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package  集合;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         测试队列</span><br><span class="line">        QueueTest queue = new QueueTest();</span><br><span class="line">        queue.put(&quot;我是第1个进入队列的&quot;);</span><br><span class="line">        queue.put(&quot;我是第2个进入队列的&quot;);</span><br><span class="line">        queue.put(&quot;我是第3个进入队列的&quot;);</span><br><span class="line">        queue.put(&quot;我是第4个进入队列的&quot;);</span><br><span class="line">         遍历队列</span><br><span class="line">        while (!queue.isEmpty())&#123;</span><br><span class="line">            String str = queue.get();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">         打印结果</span><br><span class="line">        我是第1个进入队列的</span><br><span class="line">        我是第2个进入队列的</span><br><span class="line">        我是第3个进入队列的</span><br><span class="line">        我是第4个进入队列的</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/07/集合/" data-id="cjgwezle700009ctzu6mk0hdg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第六课" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/05/第六课/" class="article-date">
  <time datetime="2018-04-05T11:19:01.579Z" itemprop="datePublished">2018-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/05/第六课/">复习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="复习："><a href="#复习：" class="headerlink" title="复习："></a>复习：</h2><pre><code>接口：接口实际上是一个更加抽象的抽象类
接口的属性都是常量 public static final。
接口的方法都是抽象方法 public abstract。

抽象类和接口的异同
共同点    接口可以认为是一个特殊的抽象类，不能实例化，实现或者继承之后都必须实现所有抽象的方法
不同点    关键字不一样abstract，interface，抽象类有普通的属性和方法，抽象类只能单继承，接口可以多实现

static  abstract    final

内部类： 静态内部类 成员内部类 匿名内部类 局部内部类

异常：

非受检异常（运行期异常）：编译器不检查方法是否可能出现这种异常。
受检异常（非运行期异常）：编译器会强制要求解决异常才可以编译。

throw ：通过throw“手动”抛出一个异常
throws：是“包含”的意思，声明该方法在执行过程中，可能会向调用者抛出一个异常对象。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    //可能发生异常的地方</span><br><span class="line">&#125;catch&#123;</span><br><span class="line">    //处理异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>finally：
1. 必定执行，除非在try中执行System.exit(0);
2. finally中无法改变try中的变量的返回值。
3. finally中可以通过return代替try区域的返回值。（finnaly中尽量避免包含return）

Object：
toString() hashCode() equals()

String字符串：
注意常量池的存在
</code></pre><h2 id="新课："><a href="#新课：" class="headerlink" title="新课："></a>新课：</h2><h3 id="一、包装类："><a href="#一、包装类：" class="headerlink" title="一、包装类："></a>一、包装类：</h3><h4 id="1、八个包装类型："><a href="#1、八个包装类型：" class="headerlink" title="1、八个包装类型："></a>1、八个包装类型：</h4><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
<p>包装类：<br>    包装类提供了多个方法，能在基本数据类型和String类型之间互相转换，还提供了处理基本数据类型时非常有用的其他一些常量和方法。</p>
<pre><code>toBinaryString(int i)   以二进制（基数2）无符号整数形式返回一个整数参数的字符串表示形式。

这里的学习结合java api来学习！！！！！

在jdk1.5之后，对于拆包和包装的操作是自动执行。
</code></pre><h3 id="二、StringBuilder和StringBuffer"><a href="#二、StringBuilder和StringBuffer" class="headerlink" title="二、StringBuilder和StringBuffer"></a>二、StringBuilder和StringBuffer</h3><pre><code>String： 不可变的字符序列
StringBuffer： 线程安全的可变长字符序列
StringBuilder： 非线程安全的可变长字符序列

String的操作室复制和创建新的char[]。
StringBuilder或者StringBuffer是操作的原始对象。

//因为这些方法返回的就是被修改的StringBuilder对象本身，所以可以连着写
sb.append(&quot;d&quot;).insert(2, &quot;e&quot;).delete(1, 3);

StringBuilder的特点：
1、StringBuilder是可变长的字符串
2、StringBuilder的一些方法：insert，append等等，都返回StringBuilder对象本身
3、如果需要出现大量的字符串处理的时候推荐StringBuilder
4、//String s = s1 + s2;    
    String s = new StringBuilder(s1).append(s2).toString();//实际上的运行方式
    String s = s1 + s2 + s3...;
    String s = new StringBuilder(s1).append(s2).append(s3).toString();

StringBuilder的api和StringBuffer的Api是基本一致的。

注意：
1、s+=&quot;a&quot;;相当于s= new StringBuilder(s).apend(&quot;a&quot;).toString();
2、当处理少量的字符串拼接，String a = b + c;大量的字符串操作，主动使用StringBuilder
3、如果要求更高的效率，那么可以使用char[];
</code></pre><h3 id="三、正则表达式"><a href="#三、正则表达式" class="headerlink" title="三、正则表达式"></a>三、正则表达式</h3><pre><code>1、正则表达式：负责处理字符串格式匹配的处理规则
    学习建议：能够基本读懂简单的正则表达式，能够写出简单的正则表达式，不要花很多的时间在正则表达式。
    学习网址：
    http://www.runoob.com/regexp/regexp-syntax.html

2、常用的规则：
必须要出现多少次的规则：
*    匹配前面的子表达式零次或多次。例如，zo* 能匹配 &quot;z&quot; 以及 &quot;zoo&quot;。* 等价于{0,}。
+    匹配前面的子表达式一次或多次。例如，&apos;zo+&apos; 能匹配 &quot;zo&quot; 以及 &quot;zoo&quot;，但不能匹配 &quot;z&quot;。+ 等价于 {1,}。
?    匹配前面的子表达式零次或一次。例如，&quot;do(es)?&quot; 可以匹配 &quot;do&quot; 或 &quot;does&quot; 中的&quot;do&quot; 。? 等价于 {0,1}。
{n}    n 是一个非负整数。匹配确定的 n 次。例如，&apos;o{2}&apos; 不能匹配 &quot;Bob&quot; 中的 &apos;o&apos;，但是能匹配 &quot;food&quot; 中的两个 o。
{n,}    n 是一个非负整数。至少匹配n 次。例如，&apos;o{2,}&apos; 不能匹配 &quot;Bob&quot; 中的 &apos;o&apos;，但能匹配 &quot;foooood&quot; 中的所有 o。&apos;o{1,}&apos; 等价于 &apos;o+&apos;。&apos;o{0,}&apos; 则等价于 &apos;o*&apos;。
{n,m}    m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，&quot;o{1,3}&quot; 将匹配 &quot;fooooood&quot; 中的前三个 o。&apos;o{0,1}&apos; 等价于 &apos;o?&apos;。请注意在逗号和两个数之间不能有空格。

常用字符：
特别字符    描述
$    匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 &apos;\n&apos; 或 &apos;\r&apos;。要匹配 $ 字符本身，请使用 \$。
( )    标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。
*    匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。
+    匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。
.    匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。
[    标记一个中括号表达式的开始。要匹配 [，请使用 \[。
?    匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。
\    将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， &apos;n&apos; 匹配字符 &apos;n&apos;。&apos;\n&apos; 匹配换行符。序列 &apos;\\&apos; 匹配 &quot;\&quot;，而 &apos;\(&apos; 则匹配 &quot;(&quot;。
^    匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。
{    标记限定符表达式的开始。要匹配 {，请使用 \{。
|    指明两项之间的一个选择。要匹配 |，请使用 \|。


下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：
字符    描述
\    
将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，&apos;n&apos; 匹配字符 &quot;n&quot;。&apos;\n&apos; 匹配一个换行符。序列 &apos;\\&apos; 匹配 &quot;\&quot; 而 &quot;\(&quot; 则匹配 &quot;(&quot;。
^    
匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 &apos;\n&apos; 或 &apos;\r&apos; 之后的位置。
$    
匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 &apos;\n&apos; 或 &apos;\r&apos; 之前的位置。
*    
匹配前面的子表达式零次或多次。例如，zo* 能匹配 &quot;z&quot; 以及 &quot;zoo&quot;。* 等价于{0,}。
+    
匹配前面的子表达式一次或多次。例如，&apos;zo+&apos; 能匹配 &quot;zo&quot; 以及 &quot;zoo&quot;，但不能匹配 &quot;z&quot;。+ 等价于 {1,}。
?    
匹配前面的子表达式零次或一次。例如，&quot;do(es)?&quot; 可以匹配 &quot;do&quot; 或 &quot;does&quot; 。? 等价于 {0,1}。
{n}    
n 是一个非负整数。匹配确定的 n 次。例如，&apos;o{2}&apos; 不能匹配 &quot;Bob&quot; 中的 &apos;o&apos;，但是能匹配 &quot;food&quot; 中的两个 o。
{n,}    
n 是一个非负整数。至少匹配n 次。例如，&apos;o{2,}&apos; 不能匹配 &quot;Bob&quot; 中的 &apos;o&apos;，但能匹配 &quot;foooood&quot; 中的所有 o。&apos;o{1,}&apos; 等价于 &apos;o+&apos;。&apos;o{0,}&apos; 则等价于 &apos;o*&apos;。
{n,m}    
m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，&quot;o{1,3}&quot; 将匹配 &quot;fooooood&quot; 中的前三个 o。&apos;o{0,1}&apos; 等价于 &apos;o?&apos;。请注意在逗号和两个数之间不能有空格。
?    
当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 &quot;oooo&quot;，&apos;o+?&apos; 将匹配单个 &quot;o&quot;，而 &apos;o+&apos; 将匹配所有 &apos;o&apos;。
.    
匹配除 &quot;\n&quot; 之外的任何单个字符。要匹配包括 &apos;\n&apos; 在内的任何字符，请使用像&quot;(.|\n)&quot;的模式。
(pattern)    
匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 &apos;\(&apos; 或 &apos;\)&apos;。
(?:pattern)    
匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 &quot;或&quot; 字符 (|) 来组合一个模式的各个部分是很有用。例如， &apos;industr(?:y|ies) 就是一个比 &apos;industry|industries&apos; 更简略的表达式。
(?=pattern)    
正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，&apos;Windows (?=95|98|NT|2000)&apos; 能匹配 &quot;Windows 2000&quot; 中的 &quot;Windows&quot; ，但不能匹配 &quot;Windows 3.1&quot; 中的 &quot;Windows&quot;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(?!pattern)    
负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如&apos;Windows (?!95|98|NT|2000)&apos; 能匹配 &quot;Windows 3.1&quot; 中的 &quot;Windows&quot;，但不能匹配 &quot;Windows 2000&quot; 中的 &quot;Windows&quot;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
x|y    
匹配 x 或 y。例如，&apos;z|food&apos; 能匹配 &quot;z&quot; 或 &quot;food&quot;。&apos;(z|f)ood&apos; 则匹配 &quot;zood&quot; 或 &quot;food&quot;。
[xyz]    
字符集合。匹配所包含的任意一个字符。例如， &apos;[abc]&apos; 可以匹配 &quot;plain&quot; 中的 &apos;a&apos;。
[^xyz]    
负值字符集合。匹配未包含的任意字符。例如， &apos;[^abc]&apos; 可以匹配 &quot;plain&quot; 中的&apos;p&apos;、&apos;l&apos;、&apos;i&apos;、&apos;n&apos;。
[a-z]    
字符范围。匹配指定范围内的任意字符。例如，&apos;[a-z]&apos; 可以匹配 &apos;a&apos; 到 &apos;z&apos; 范围内的任意小写字母字符。
[^a-z]    
负值字符范围。匹配任何不在指定范围内的任意字符。例如，&apos;[^a-z]&apos; 可以匹配任何不在 &apos;a&apos; 到 &apos;z&apos; 范围内的任意字符。
\b    
匹配一个单词边界，也就是指单词和空格间的位置。例如， &apos;er\b&apos; 可以匹配&quot;never&quot; 中的 &apos;er&apos;，但不能匹配 &quot;verb&quot; 中的 &apos;er&apos;。
\B    
匹配非单词边界。&apos;er\B&apos; 能匹配 &quot;verb&quot; 中的 &apos;er&apos;，但不能匹配 &quot;never&quot; 中的 &apos;er&apos;。
\cx    
匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 &apos;c&apos; 字符。
\d    
匹配一个数字字符。等价于 [0-9]。
\D    
匹配一个非数字字符。等价于 [^0-9]。
\f    
匹配一个换页符。等价于 \x0c 和 \cL。
\n    
匹配一个换行符。等价于 \x0a 和 \cJ。
\r    
匹配一个回车符。等价于 \x0d 和 \cM。
\s    
匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S    
匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\t    
匹配一个制表符。等价于 \x09 和 \cI。
\v    
匹配一个垂直制表符。等价于 \x0b 和 \cK。
\w    
匹配包括下划线的任何单词字符。等价于&apos;[A-Za-z0-9_]&apos;。
\W    
匹配任何非单词字符。等价于 &apos;[^A-Za-z0-9_]&apos;。
\xn    
匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，&apos;\x41&apos; 匹配 &quot;A&quot;。&apos;\x041&apos; 则等价于 &apos;\x04&apos; &amp; &quot;1&quot;。正则表达式中可以使用 ASCII 编码。
\num    
匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，&apos;(.)\1&apos; 匹配两个连续的相同字符。
\n    
标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。
\nm    
标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。
\nml    
如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。
\un    
匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。
</code></pre><h4 id="3、使用："><a href="#3、使用：" class="headerlink" title="3、使用："></a>3、使用：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义规则</span></span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"^[a-z]&#123;1,5&#125;$"</span>);</span><br><span class="line"><span class="comment">//创建匹配的参数</span></span><br><span class="line">Matcher m = p.matcher(<span class="string">"abc1"</span>);</span><br><span class="line">System.out.println(m.matches());<span class="comment">//匹配</span></span><br></pre></td></tr></table></figure>
<h4 id="4、比较三种匹配方法的区别："><a href="#4、比较三种匹配方法的区别：" class="headerlink" title="4、比较三种匹配方法的区别："></a>4、比较三种匹配方法的区别：</h4><pre><code>matches 方法尝试将整个输入序列与该模式匹配。 

lookingAt 尝试将输入序列从头开始与该模式匹配。 

find 方法扫描输入序列以查找与该模式匹配的下一个子序列。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义规则</span></span><br><span class="line"><span class="comment">//		Pattern p = Pattern.compile("^[a-z]&#123;1,5&#125;$");</span></span><br><span class="line"><span class="comment">//		//创建匹配的参数</span></span><br><span class="line"><span class="comment">//		Matcher m = p.matcher("abc1");</span></span><br><span class="line"><span class="comment">//		System.out.println(m.matches());//匹配</span></span><br><span class="line">	</span><br><span class="line">	Pattern p = Pattern.compile(<span class="string">"[a-z]&#123;1,5&#125;"</span>);</span><br><span class="line">	Matcher m = p.matcher(<span class="string">"abc,bcde,ddd,123"</span>);</span><br><span class="line"><span class="comment">//		matches 方法尝试将整个输入序列与该模式匹配。 移动到下次匹配的位置</span></span><br><span class="line">	System.out.println(m.matches());</span><br><span class="line">	</span><br><span class="line"><span class="comment">//		find 方法扫描输入序列以查找与该模式匹配的下一个子序列。找到一个匹配位置之后会移动到下一次的匹配位置</span></span><br><span class="line">	System.out.println(m.find());</span><br><span class="line">	<span class="comment">//group匹配的内容	start显示从哪个索引开始进行匹配</span></span><br><span class="line">	System.out.println(m.group() + <span class="string">":"</span> + m.start());</span><br><span class="line">	</span><br><span class="line">	System.out.println(m.find());</span><br><span class="line">	System.out.println(m.group() + <span class="string">":"</span> + m.start());</span><br><span class="line">	</span><br><span class="line"><span class="comment">//		System.out.println(m.find());</span></span><br><span class="line"><span class="comment">//		System.out.println(m.group() + ":" + m.start());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//		lookingAt 尝试将输入序列从头开始与该模式匹配。 开头匹配不了，后面也就不检查了</span></span><br><span class="line">	System.out.println(m.lookingAt());</span><br><span class="line">	System.out.println(m.group() + <span class="string">":"</span> + m.start());</span><br></pre></td></tr></table></figure>
<h4 id="5、字符串对正则表达式的支持"><a href="#5、字符串对正则表达式的支持" class="headerlink" title="5、字符串对正则表达式的支持"></a>5、字符串对正则表达式的支持</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串匹配正则表达式</span></span><br><span class="line">String str = <span class="string">"abcde11"</span>;</span><br><span class="line">System.out.println(str.matches(<span class="string">"[a-z]&#123;1,5&#125;"</span>));</span><br><span class="line"></span><br><span class="line">String str1 = <span class="string">"abc,bcd|eee"</span>;</span><br><span class="line"><span class="comment">//切割字符串的正则表达式应用</span></span><br><span class="line">String strs[] = str1.split(<span class="string">"[,|]"</span>);</span><br><span class="line"><span class="keyword">for</span> (String string : strs) &#123;</span><br><span class="line">	System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//替换方法的正则表达式应用</span></span><br><span class="line">System.out.println(str.replaceAll(<span class="string">"[a-z]"</span>, <span class="string">"x"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="四、反射"><a href="#四、反射" class="headerlink" title="四、反射"></a>四、反射</h3><pre><code>反射机制的概念：
允许程序在运行的时候透过这种机制来获取任意一个已知名称的类的内部信息。

java反射机制所提供的功能（都是在运行期）：
判断任意一个对象所属的类
构造任意一个对象
判断任意一个类所具有的成员变量和方法
调用任意一个对象的方法

例子：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">//获取类信息的方式(通过类名)</span><br><span class="line">Class userClass = User.class;</span><br><span class="line">System.out.println(userClass);</span><br><span class="line"></span><br><span class="line">//通过对象的getClass方法来获取类的信息</span><br><span class="line">User user = new User();</span><br><span class="line">userClass = user.getClass();</span><br><span class="line"></span><br><span class="line">//使用Class类的forName依据全类名来获取类的信息</span><br><span class="line">try &#123;</span><br><span class="line">	userClass = Class.forName(&quot;反射.User&quot;);</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过名称来获取属性信息</span><br><span class="line">try &#123;</span><br><span class="line">	Field field = userClass.getField(&quot;uname&quot;);</span><br><span class="line">	System.out.println(field);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;===============&quot;);</span><br><span class="line">//获取public的属性信息,也可以获取继承自父类的属性</span><br><span class="line">Field[] fields = userClass.getFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">	System.out.println(field);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;===============&quot;);</span><br><span class="line">//本类的所有的属性信息（包含私有的），不可以获取继承自父类的属性</span><br><span class="line">fields = userClass.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">	System.out.println(field);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">	//确定一个方法必须确定方法签名</span><br><span class="line">	Method method = userClass.getMethod(&quot;show&quot;, int.class);</span><br><span class="line">	System.out.println(method);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">//获取所有方法的信息</span><br><span class="line">Method[] methods = userClass.getMethods();</span><br><span class="line">for (Method method : methods) &#123;</span><br><span class="line">	System.out.println(method);</span><br><span class="line">	//获取方法的信息</span><br><span class="line">//			Class[] classes = method.getParameterTypes();</span><br><span class="line">//			for (Class class1 : classes) &#123;</span><br><span class="line">//				System.out.println(class1);</span><br><span class="line">//			&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取构造方法</span><br><span class="line">Constructor[] constructors = userClass.getConstructors();</span><br><span class="line">for (Constructor constructor : constructors) &#123;</span><br><span class="line">	System.out.println(constructor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可以使用构造方法的信息类的newInstance方法来创建具体的对象</span><br><span class="line">try &#123;</span><br><span class="line">	user = (User) userClass.getConstructor(String.class,int.class,float.class,int.class).newInstance(&quot;zbh&quot;,18,100,11);</span><br><span class="line">	System.out.println(user);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">	Field field = userClass.getField(&quot;uname&quot;);</span><br><span class="line">	//设置参数，必须知道给哪一个对象设置</span><br><span class="line">	field.set(user, &quot;wwk&quot;);</span><br><span class="line">	//获取属性的值，说明获取的哪一个对象的属性</span><br><span class="line">	System.out.println(field.get(user));</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">	//确定一个方法必须确定方法签名</span><br><span class="line">	Method method = userClass.getMethod(&quot;show&quot;, int.class);</span><br><span class="line">	//执行方法必须告诉是哪一个对象的方法</span><br><span class="line">	method.invoke(user, 10);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">	Field field = userClass.getDeclaredField(&quot;age&quot;);</span><br><span class="line">	field.setAccessible(true);//抑制java的访问检查</span><br><span class="line">	//设置参数，必须知道给哪一个对象设置</span><br><span class="line">	field.set(user, 20);</span><br><span class="line">	//获取属性的值，说明获取的哪一个对象的属性</span><br><span class="line">	System.out.println(user);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、java-util包"><a href="#五、java-util包" class="headerlink" title="五、java.util包"></a>五、java.util包</h3><pre><code>日期    日历    随机数  集合
</code></pre><h4 id="1、日期"><a href="#1、日期" class="headerlink" title="1、日期"></a>1、日期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">创建日期：</span><br><span class="line">Date date = new Date();//系统时间</span><br><span class="line"></span><br><span class="line">//格式转化(SimpleDateFormat)</span><br><span class="line">SimpleDateFormat siFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">//将日期转化为字符串</span><br><span class="line">String dateStr = siFormat.format(date);</span><br><span class="line">//将字符串转化为日期</span><br><span class="line">date = siFormat.parse(dateStr);</span><br></pre></td></tr></table></figure>
<h4 id="2、数字格式化："><a href="#2、数字格式化：" class="headerlink" title="2、数字格式化："></a>2、数字格式化：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建格式化对象</span><br><span class="line">DecimalFormat df = (DecimalFormat) NumberFormat.getInstance();</span><br><span class="line">//设置某个数的小数部分中所允许的最大数字位数(保留的小数位数)</span><br><span class="line">//df.setMaximumFractionDigits(2);</span><br><span class="line">//自定义规则</span><br><span class="line">df.applyPattern(&quot;0.##&quot;);</span><br><span class="line">System.out.println(df.format(12.34567));</span><br></pre></td></tr></table></figure>
<h4 id="3、日历："><a href="#3、日历：" class="headerlink" title="3、日历："></a>3、日历：</h4><pre><code>//获取当前的日期
Calendar calendar = Calendar.getInstance();
int year = calendar.get(Calendar.YEAR);

//将给定的日历字段设置为给定值2018年3月2日16时50分12秒
//calendar.set(Calendar.MONTH, 13);
//根据日历的规则，为给定的日历字段添加或减去指定的时间量2018年2月28日16时50分12秒
//calendar.add(Calendar.MONTH, 13);
//在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。2017年2月28日16时53分3秒
calendar.roll(Calendar.MONTH, 13);

//获取月份的最后一天
calendar.set(Calendar.DATE, 1);
calendar.roll(Calendar.DATE, -1);
</code></pre><h4 id="4、随机数："><a href="#4、随机数：" class="headerlink" title="4、随机数："></a>4、随机数：</h4><pre><code>//默认的随机种子是根据时间变化的
Random random = new Random();
for (int i = 0; i &lt; 100; i++) {
    System.out.println(random.nextInt(100)+1);//设置1-100的随机数
}
</code></pre><p>作业：<br>1、不利用Integer.parseInt()方法将一个字符串转化为对应的数值，并且查看自己方法和Integer.parseInt()方法的效率差距。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/05/第六课/" data-id="cjgwezleg00029ctzxu3cro0n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/05/hello-world/" class="article-date">
  <time datetime="2018-04-05T09:17:45.612Z" itemprop="datePublished">2018-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/05/hello-world/">第一条博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="以后尽量每周写篇博客，做个勤快的小蜜蜂"><a href="#以后尽量每周写篇博客，做个勤快的小蜜蜂" class="headerlink" title="以后尽量每周写篇博客，做个勤快的小蜜蜂 *_*"></a>以后尽量每周写篇博客，做个勤快的小蜜蜂 *_*</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/05/hello-world/" data-id="cjgwezlec00019ctzfja82l7s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/05/07/集合/">集合</a>
          </li>
        
          <li>
            <a href="/2018/04/05/第六课/">复习</a>
          </li>
        
          <li>
            <a href="/2018/04/05/hello-world/">第一条博客</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 POPJny<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>